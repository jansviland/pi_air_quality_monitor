<html><head>  <title>Plot Type: Heatmap - ScottPlot 4.1 Cookbook</title>  <link href=https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css rel=stylesheet></head><body class=bg-light>  <div class='container' style='max-width:1000px'>    <div class='my-4'><code>THIS PAGE IS FOR TESTING ONLY</code></div>    <div class='display-4'>Plot Type: Heatmap - ScottPlot 4.1 Cookbook</div>    <div class='fs-5'><i>Heatmaps display a 2D array using a colormap.</i></div>    <article class='bg-light shadow rounded my-5'>    <div class='p-3 rounded bg-white'>      This page contains recipes for the <i>Heatmap</i> category.<br>Visit the <a href='../../index.dev.html'>Cookbook Home Page</a> to view all cookbook recipes.
<h3 class='mt-5' id='heatmap-quickstart'>Heatmap Quickstart</h3>
<div>Heatmaps display a 2D array using a colormap.</div>
<pre class='bg-light border rounded p-3'>var plt = new ScottPlot.Plot(600, 400);

double[,] data2D = { { 1, 2, 3 },
         { 4, 5, 6 } };

plt.AddHeatmap(data2D);

plt.SaveFig("heatmap_quickstart.png");</pre>
<img src='../../images/heatmap_quickstart.png' class='d-block mx-auto my-5 border shadow-sm' style='max-width: 100%;'/>

<h3 class='mt-5' id='flipped-heatmap'>Flipped Heatmap</h3>
<div>Heatmaps can be flipped vertically and/or horizontally.</div>
<pre class='bg-light border rounded p-3'>var plt = new ScottPlot.Plot(600, 400);

double[,] data = ScottPlot.DataGen.SampleImageData();

var hm1 = plt.AddHeatmap(data, lockScales: false);
hm1.XMin = 0;

var hm2 = plt.AddHeatmap(data, lockScales: false);
hm2.XMin = 100;
hm2.FlipHorizontally = true;

var hm3 = plt.AddHeatmap(data, lockScales: false);
hm3.XMin = 200;
hm3.FlipVertically = true;

var hm4 = plt.AddHeatmap(data, lockScales: false);
hm4.XMin = 300;
hm4.FlipVertically = true;
hm4.FlipHorizontally = true;

plt.SaveFig("heatmap_flip.png");</pre>
<img src='../../images/heatmap_flip.png' class='d-block mx-auto my-5 border shadow-sm' style='max-width: 100%;'/>

<h3 class='mt-5' id='heatmap-with-tight-margins'>Heatmap with Tight Margins</h3>
<div>The heatmap can fit the plot area exactly if margins are set to zero and the square axis lock is disabled.</div>
<pre class='bg-light border rounded p-3'>var plt = new ScottPlot.Plot(600, 400);

double[,] data2D = { { 1, 2, 3 },
         { 4, 5, 6 } };

plt.AddHeatmap(data2D, lockScales: false);
plt.Margins(0, 0);

plt.SaveFig("heatmap_margins.png");</pre>
<img src='../../images/heatmap_margins.png' class='d-block mx-auto my-5 border shadow-sm' style='max-width: 100%;'/>

<h3 class='mt-5' id='heatmap-with-colorbar'>Heatmap with Colorbar</h3>
<div>Colorbars are often added when heatmaps are used.</div>
<pre class='bg-light border rounded p-3'>var plt = new ScottPlot.Plot(600, 400);

double[,] data2D = { { 1, 2, 3 },
         { 4, 5, 6 } };

var hm = plt.AddHeatmap(data2D, lockScales: false);
var cb = plt.AddColorbar(hm);
plt.Margins(0, 0);

plt.SaveFig("heatmap_colorbar.png");</pre>
<img src='../../images/heatmap_colorbar.png' class='d-block mx-auto my-5 border shadow-sm' style='max-width: 100%;'/>

<h3 class='mt-5' id='smooth-heatmap'>Smooth Heatmap</h3>
<div>Heatmaps display values as rectangles with sharp borders by default. Enabling the Smooth feature uses bicubic interpolation to display the heatmap as a smooth gradient between values.</div>
<pre class='bg-light border rounded p-3'>var plt = new ScottPlot.Plot(600, 400);

var rand = new Random(0);
double[,] data2D = DataGen.Random2D(rand, 5, 4);

var hm = plt.AddHeatmap(data2D, lockScales: false);
hm.Smooth = true;

plt.SaveFig("heatmap_smooth.png");</pre>
<img src='../../images/heatmap_smooth.png' class='d-block mx-auto my-5 border shadow-sm' style='max-width: 100%;'/>

<h3 class='mt-5' id='heatmap-image'>Heatmap Image</h3>
<div>Image data can be plotted using the heatmap plot type.</div>
<pre class='bg-light border rounded p-3'>var plt = new ScottPlot.Plot(600, 400);

double[,] imageData = DataGen.SampleImageData();
plt.AddHeatmap(imageData);

plt.SaveFig("heatmap_image.png");</pre>
<img src='../../images/heatmap_image.png' class='d-block mx-auto my-5 border shadow-sm' style='max-width: 100%;'/>

<h3 class='mt-5' id='heatmap-opacity'>Heatmap Opacity</h3>
<div>Heatmaps have an Opacity property that can be set anywhere from 0 (transparent) to 1 (opaque).</div>
<pre class='bg-light border rounded p-3'>var plt = new ScottPlot.Plot(600, 400);

double[,] imageData = DataGen.SampleImageData();
var hm = plt.AddHeatmap(imageData);
hm.Opacity = 0.5;

plt.SaveFig("heatmap_opacity.png");</pre>
<img src='../../images/heatmap_opacity.png' class='d-block mx-auto my-5 border shadow-sm' style='max-width: 100%;'/>

<h3 class='mt-5' id='single-color-heatmap'>Single Color Heatmap</h3>
<div>A single-color heatmap can be created where cell transparency is defined by a 2D array containing values 0 to 1.</div>
<pre class='bg-light border rounded p-3'>var plt = new ScottPlot.Plot(600, 400);

double?[,] data = DataGen.SampleImageDataNullable();

var hm1 = plt.AddHeatmap(Color.Red, data, lockScales: false);
hm1.OffsetX = 0;
hm1.OffsetY = 0;

var hm2 = plt.AddHeatmap(Color.Green, data, lockScales: false);
hm2.OffsetX = 30;
hm2.OffsetY = 20;

var hm3 = plt.AddHeatmap(Color.Blue, data, lockScales: false);
hm3.OffsetX = 60;
hm3.OffsetY = 40;

plt.SaveFig("heatmap_single_color.png");</pre>
<img src='../../images/heatmap_single_color.png' class='d-block mx-auto my-5 border shadow-sm' style='max-width: 100%;'/>

<h3 class='mt-5' id='2d-waveform'>2D Waveform</h3>
<div>This example demonstrates a heatmap with 1000 tiles</div>
<pre class='bg-light border rounded p-3'>var plt = new ScottPlot.Plot(600, 400);

int width = 100;
int height = 100;

double[,] intensities = new double[width, height];

for (int x = 0; x < width; x++)
    for (int y = 0; y < height; y++)
        intensities[x, y] = (Math.Sin(x * .2) + Math.Cos(y * .2)) * 100;

var hm = plt.AddHeatmap(intensities);
var cb = plt.AddColorbar(hm);

plt.SaveFig("heatmap_2dWaveform.png");</pre>
<img src='../../images/heatmap_2dwaveform.png' class='d-block mx-auto my-5 border shadow-sm' style='max-width: 100%;'/>

<h3 class='mt-5' id='colormap'>Colormap</h3>
<div>Viridis is the default colormap, but several alternatives are available.</div>
<pre class='bg-light border rounded p-3'>var plt = new ScottPlot.Plot(600, 400);

double[,] intensities = new double[100, 100];
for (int x = 0; x < 100; x++)
    for (int y = 0; y < 100; y++)
        intensities[x, y] = (Math.Sin(x * .2) + Math.Cos(y * .2)) * 100;

var hm = plt.AddHeatmap(intensities, Drawing.Colormap.Turbo);
var cb = plt.AddColorbar(hm);

plt.SaveFig("heatmap_colormap.png");</pre>
<img src='../../images/heatmap_colormap.png' class='d-block mx-auto my-5 border shadow-sm' style='max-width: 100%;'/>

<h3 class='mt-5' id='styled-colormap'>Styled Colormap</h3>
<div>Viridis is the default colormap, but several alternatives are available.</div>
<pre class='bg-light border rounded p-3'>var plt = new ScottPlot.Plot(600, 400);

double[,] intensities = new double[100, 100];
for (int x = 0; x < 100; x++)
    for (int y = 0; y < 100; y++)
        intensities[x, y] = (Math.Sin(x * .2) + Math.Cos(y * .2)) * 100;

var hm = plt.AddHeatmap(intensities, Drawing.Colormap.Turbo);
var cb = plt.AddColorbar(hm);

plt.Style(Style.Black);

plt.SaveFig("styled_heatmap_colormap.png");</pre>
<img src='../../images/styled_heatmap_colormap.png' class='d-block mx-auto my-5 border shadow-sm' style='max-width: 100%;'/>

<h3 class='mt-5' id='palette-colormap'>Palette Colormap</h3>
<div>Heatmap data can be presented using a colormap defined by a fixed set of colors.</div>
<pre class='bg-light border rounded p-3'>var plt = new ScottPlot.Plot(600, 400);

double[,] data = DataGen.SampleImageData();

// create a colormap from a defined set of colors
Color[] colors = { Color.Indigo, Color.Blue, Color.Green, Color.Yellow, Color.Orange, Color.Red, };

// display the colormap on the plot as a colorbar
ScottPlot.Drawing.Colormap cmap = new(colors);
var cbar = plt.AddColorbar(cmap);
cbar.MaxValue = 255;

// use custom tick positions
double[] tickPositions = Enumerable.Range(0, colors.Length + 1)
    .Select(x => (double)x / colors.Length)
    .ToArray();
string[] tickLabels = tickPositions.Select(x => $"{x * 255:N2}").ToArray();
cbar.SetTicks(tickPositions, tickLabels);

// add a heatmap using the custom colormap
plt.AddHeatmap(data, cmap);

plt.SaveFig("heatmap_palette.png");</pre>
<img src='../../images/heatmap_palette.png' class='d-block mx-auto my-5 border shadow-sm' style='max-width: 100%;'/>

<h3 class='mt-5' id='scale-limits'>Scale Limits</h3>
<div>Heatmap colormap scale can use a defined min/max value.</div>
<pre class='bg-light border rounded p-3'>var plt = new ScottPlot.Plot(600, 400);

double[,] intensities = new double[100, 100];
for (int x = 0; x < 100; x++)
    for (int y = 0; y < 100; y++)
        intensities[x, y] = (Math.Sin(x * .2) + Math.Cos(y * .2)) * 100;

// scale the colors between 0 and 200
var hm = plt.AddHeatmap(intensities);
hm.Update(intensities, min: 0, max: 200);

// add a colorbar with custom ticks
var cb = plt.AddColorbar(hm);
double[] tickPositions = ScottPlot.DataGen.Range(0, 200, 25, true);
string[] tickLabels = tickPositions.Select(x => x.ToString()).ToArray();
cb.SetTicks(tickPositions, tickLabels, min: 0, max: 200);

plt.SaveFig("heatmap_limitScale.png");</pre>
<img src='../../images/heatmap_limitscale.png' class='d-block mx-auto my-5 border shadow-sm' style='max-width: 100%;'/>

<h3 class='mt-5' id='color-clipping'>Color Clipping</h3>
<div>The value range displayed by the colormap can restricted to a narrow subset of the full data range. Tick labels at the edges of the colorbar can be made to show inequality symbols to indicate the range of data is being clipped when translating values to colors.</div>
<pre class='bg-light border rounded p-3'>var plt = new ScottPlot.Plot(600, 400);

double[,] imageData = DataGen.SampleImageData();
var heatmap = plt.AddHeatmap(imageData);
heatmap.Update(imageData, min: 75, max: 125);

var cb = plt.AddColorbar(heatmap);

// configure the colorbar to display inequality operators at the edges
cb.MaxIsClipped = true;
cb.MinIsClipped = true;

plt.SaveFig("heatmap_clip.png");</pre>
<img src='../../images/heatmap_clip.png' class='d-block mx-auto my-5 border shadow-sm' style='max-width: 100%;'/>

<h3 class='mt-5' id='interpolation-by-density'>Interpolation by Density</h3>
<div>Heatmaps can be created from random 2D data points using the count within a square of fixed size.</div>
<pre class='bg-light border rounded p-3'>var plt = new ScottPlot.Plot(600, 400);

Random rand = new Random(0);
int[] xs = DataGen.RandomNormal(rand, 10000, 25, 10).Select(x => (int)x).ToArray();
int[] ys = DataGen.RandomNormal(rand, 10000, 25, 10).Select(y => (int)y).ToArray();

double[,] intensities = Tools.XYToIntensities(mode: IntensityMode.Density,
    xs: xs, ys: ys, width: 50, height: 50, sampleWidth: 4);

var hm = plt.AddHeatmap(intensities);
var cb = plt.AddColorbar(hm);

plt.SaveFig("heatmap_density.png");</pre>
<img src='../../images/heatmap_density.png' class='d-block mx-auto my-5 border shadow-sm' style='max-width: 100%;'/>

<h3 class='mt-5' id='gaussian-interpolation'>Gaussian Interpolation</h3>
<div>Heatmaps can be created from 2D data points using bilinear interpolation with Gaussian weighting. This option results in a heatmap with a standard deviation of 4.</div>
<pre class='bg-light border rounded p-3'>var plt = new ScottPlot.Plot(600, 400);

Random rand = new Random(0);
int[] xs = DataGen.RandomNormal(rand, 10000, 25, 10).Select(x => (int)x).ToArray();
int[] ys = DataGen.RandomNormal(rand, 10000, 25, 10).Select(y => (int)y).ToArray();

double[,] intensities = Tools.XYToIntensities(mode: IntensityMode.Gaussian,
    xs: xs, ys: ys, width: 50, height: 50, sampleWidth: 4);

var hm = plt.AddHeatmap(intensities);
var cb = plt.AddColorbar(hm);

plt.SaveFig("heatmap_gaussian.png");</pre>
<img src='../../images/heatmap_gaussian.png' class='d-block mx-auto my-5 border shadow-sm' style='max-width: 100%;'/>

<h3 class='mt-5' id='custom-dimensions'>Custom Dimensions</h3>
<div>By default heatmaps start at the origin and each rectangle (cell) is 1 unit in size, but heatmap offset and cell size can be customized.</div>
<pre class='bg-light border rounded p-3'>var plt = new ScottPlot.Plot(600, 400);

double[,] data2D = { { 1, 2, 3 },
         { 4, 5, 6 } };

var hm = plt.AddHeatmap(data2D, lockScales: false);
hm.OffsetX = 10;
hm.OffsetY = 20;
hm.CellWidth = 5;
hm.CellHeight = 10;

plt.SaveFig("heatmap_dimensions.png");</pre>
<img src='../../images/heatmap_dimensions.png' class='d-block mx-auto my-5 border shadow-sm' style='max-width: 100%;'/>

<h3 class='mt-5' id='heatmap-with-empty-squares'>Heatmap with Empty Squares</h3>
<div>You can use a 2D array of nullable doubles to indicate some squares do not contain data. This allows the user to display heatmaps with transparency and implement non-rectangular heatmaps.</div>
<pre class='bg-light border rounded p-3'>var plt = new ScottPlot.Plot(600, 400);

double?[,] intensities = {
    { 1, 7, 4, null },
    { 9, null, 2, 4 },
    { 1, 4, null, 8 },
    { null, 2, 4, null }
};

var hmc = plt.AddHeatmap(intensities);
var cb = plt.AddColorbar(hmc);

plt.SaveFig("heatmap_transparent.png");</pre>
<img src='../../images/heatmap_transparent.png' class='d-block mx-auto my-5 border shadow-sm' style='max-width: 100%;'/>

<h3 class='mt-5' id='size-and-placement'>Size and Placement</h3>
<div>Edges of the heatmap can be defined as an alternative to defining offset and cell size,</div>
<pre class='bg-light border rounded p-3'>var plt = new ScottPlot.Plot(600, 400);

double[,] imageData = DataGen.SampleImageData();
var hm = plt.AddHeatmap(imageData, lockScales: false);

hm.XMin = -100;
hm.XMax = 100;
hm.YMin = -10;
hm.YMax = 10;

plt.SaveFig("heatmap_placement.png");</pre>
<img src='../../images/heatmap_placement.png' class='d-block mx-auto my-5 border shadow-sm' style='max-width: 100%;'/>

<h3 class='mt-5' id='heatmap-clipping'>Heatmap Clipping</h3>
<div>Heatmaps can be clipped to an arbitrary polygon</div>
<pre class='bg-light border rounded p-3'>var plt = new ScottPlot.Plot(600, 400);

double[,] imageData = DataGen.SampleImageData();
var hm = plt.AddHeatmap(imageData, lockScales: false);
hm.ClippingPoints = new Coordinate[]
{
    new Coordinate(30, 15),
    new Coordinate(55, 40),
    new Coordinate(60, 45),
    new Coordinate(80, 60),
    new Coordinate(40, 95),
    new Coordinate(15, 90),
    new Coordinate(5, 50),
};

plt.SaveFig("heatmap_clipping.png");</pre>
<img src='../../images/heatmap_clipping.png' class='d-block mx-auto my-5 border shadow-sm' style='max-width: 100%;'/>

    </div>    </article>  </div></body></html>